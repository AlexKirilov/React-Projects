var Parser = require('jsonparse')
	, streams = require('stream');


exports.parse = function(path, map, opts) {
	if (typeof map == 'object' && map) {
		opts = map;
		map = null;
	}
	opts = opts || {};



	var parser = new Parser()
		, stream = new streams.Transform({
			encoding: opts.encoding,
			highWaterMark: opts.writableHighWaterMark
		});

	stream._readableState.objectMode = true;
	stream._readableState.highWaterMark = opts.readableHighWaterMark || 128;

	stream._transform = function(chunk, enc, cb) {
		parser.write(chunk);
		cb();
	};

	if('string' === typeof path) {
		path = path.split('.').map(function (e) {
			if (e === '*') {
				return true;
			} else if (e === '') {
				return { recurse: true };
			} else {
				return e;
			}
		});
	}


	var count = 0, _key;

	if(!path || !path.length){
		path = null;
	}

	parser.onValue = function () {
		if (!this.root && this.stack.length == 1) {
			stream.root = this.value;
		}

		if (!path) {
			return;
		}

		var i = 0; // iterates on path
		var j  = 0; // iterates on stack
		while (i < path.length) {
			var key = path[i];
			var c;
			j++;

			if (key && !key.recurse) {
				c = (j === this.stack.length) ? this : this.stack[j];
				if (!c) return;
				if (! check(key, c.key)) return;
				i++;
			} else {
				i++;
				var nextKey = path[i];
				if (!nextKey) return;
				while (true) {
					c = (j === this.stack.length) ? this : this.stack[j];
					if (!c) return;
					if (check(nextKey, c.key)) { i++; break; }
					j++;
				}
			}
		}
		if (j !== this.stack.length) return;

		count++;
		var actualPath = this.stack.slice(1).map(function(element) { return element.key; }).concat([this.key]);
		var data = this.value[this.key];
		if (null != data) {
			if (null != (data = map ? map(data, actualPath) : data)) {
				stream.push(data);
			}
		}
		delete this.value[this.key];
	};

	parser._onToken = parser.onToken;

	parser.onToken = function (token, value) {
		parser._onToken(token, value);
		if (this.stack.length === 0) {
			if (stream.root) {
				if(!path) {
					stream.push(stream.root);
				}
				stream.emit('root', stream.root, count);
				count = 0;
				stream.root = null;
			}
		}
	};

	parser.onError = function (err) {
		stream.emit('error', err);
	};

	return stream;
};


function check (x, y) {
	if ('string' === typeof x) {
		return y == x;
	} else if (x && 'function' === typeof x.exec) {
		return x.exec(y);
	} else if ('boolean' === typeof x) {
		return x;
	} else if ('function' === typeof x) {
		return x(y);
	}
	return false;
}
